+++ src/lib/loader/loader.cpp	2023-01-25 09:22:16.000000000 +0100
@@ -244,7 +244,86 @@
 
 /// Parse module from file path. See "include/loader/loader.h".
 Expect<std::unique_ptr<AST::Module>>
-Loader::parseModule(const std::filesystem::path &) {
+Loader::parseModule(const std::filesystem::path &FilePath) {
+
+  using namespace std::literals::string_view_literals;
+  std::lock_guard Lock(Mutex);
+  // Set path and check the header.
+  if (auto Res = FMgr.setPath(FilePath); !Res) {
+    spdlog::error(Res.error());
+    spdlog::error(ErrInfo::InfoFile(FilePath));
+    return Unexpect(Res);
+  }
+
+  switch (FMgr.getHeaderType()) {
+  case FileMgr::FileHeader::ELF:
+  case FileMgr::FileHeader::DLL:
+  case FileMgr::FileHeader::MachO_32:
+  case FileMgr::FileHeader::MachO_64: {
+    // AOT compiled shared-library-WASM cases. Use ldmgr to load the module.
+    WASMType = InputType::SharedLibrary;
+    FMgr.reset();
+    if (auto Res = LMgr.setPath(FilePath); !Res) {
+      spdlog::error(ErrInfo::InfoFile(FilePath));
+      return Unexpect(Res);
+    }
+    if (auto Res = LMgr.getVersion()) {
+      if (*Res != AOT::kBinaryVersion) {
+        spdlog::error(ErrInfo::InfoMismatch(AOT::kBinaryVersion, *Res));
+        spdlog::error(ErrInfo::InfoFile(FilePath));
+        return Unexpect(ErrCode::Value::MalformedVersion);
+      }
+    } else {
+      spdlog::error(ErrInfo::InfoFile(FilePath));
+      return Unexpect(Res);
+    }
+
+    std::unique_ptr<AST::Module> Mod;
+    if (auto Code = LMgr.getWasm()) {
+      // Set the binary and load module.
+      // Not to use parseModule() here to keep the `WASMType` value.
+      if (auto Res = FMgr.setCode(*Code); !Res) {
+        spdlog::error(ErrInfo::InfoFile(FilePath));
+        return Unexpect(Res);
+      }
+      if (auto Res = loadModule()) {
+        Mod = std::move(*Res);
+      } else {
+        spdlog::error(ErrInfo::InfoFile(FilePath));
+        return Unexpect(Res);
+      }
+    } else {
+      spdlog::error(ErrInfo::InfoFile(FilePath));
+      return Unexpect(Code);
+    }
+    if (!Conf.getRuntimeConfigure().isForceInterpreter()) {
+      // If the configure is set to force interpreter mode, not to load the AOT
+      // related data.
+      if (auto Res = loadCompiled(*Mod.get()); unlikely(!Res)) {
+        spdlog::error(ErrInfo::InfoFile(FilePath));
+        return Unexpect(Res);
+      }
+    }
+    return Mod;
+  }
+  default:
+    // Universal WASM, WASM, or other cases. Load and parse the module directly.
+    WASMType = InputType::WASM;
+    if (auto Res = loadModule()) {
+      if (!Conf.getRuntimeConfigure().isForceInterpreter()) {
+        // If the configure is set to force interpreter mode, not to set the
+        // symbol.
+        if (auto &Symbol = (*Res)->getSymbol()) {
+          *Symbol = IntrinsicsTable;
+        }
+      }
+      return std::move(*Res);
+    } else {
+      spdlog::error(ErrInfo::InfoFile(FilePath));
+      return Unexpect(Res);
+    }
+  }
+
   return Unexpect(ErrCode::Value::IllegalPath);
 }
 
@@ -262,6 +350,62 @@
   return Unexpect(ErrCode::Value::IllegalPath);
 }
 
+// Helper function of checking the valid value types.
+Expect<ValType> Loader::checkValTypeProposals(ValType VType, bool AcceptNone,
+                                              uint64_t Off,
+                                              ASTNodeAttr Node) const noexcept {
+  if (VType == ValType::V128 && !Conf.hasProposal(Proposal::SIMD)) {
+    return logNeedProposal(ErrCode::Value::MalformedValType, Proposal::SIMD,
+                           Off, Node);
+  }
+  if ((VType == ValType::FuncRef &&
+       !Conf.hasProposal(Proposal::ReferenceTypes) &&
+       !Conf.hasProposal(Proposal::BulkMemoryOperations)) ||
+      (VType == ValType::ExternRef &&
+       !Conf.hasProposal(Proposal::ReferenceTypes))) {
+    return logNeedProposal(ErrCode::Value::MalformedElemType,
+                           Proposal::ReferenceTypes, Off, Node);
+  }
+  switch (VType) {
+  case ValType::I32:
+  case ValType::I64:
+  case ValType::F32:
+  case ValType::F64:
+  case ValType::V128:
+  case ValType::ExternRef:
+  case ValType::FuncRef:
+    return VType;
+  case ValType::None:
+    if (AcceptNone) {
+      return VType;
+    }
+    [[fallthrough]];
+  default:
+    return logLoadError(ErrCode::Value::MalformedValType, Off, Node);
+  }
+}
+
+// Helper function of checking the valid reference types.
+Expect<RefType> Loader::checkRefTypeProposals(RefType RType, uint64_t Off,
+                                              ASTNodeAttr Node) const noexcept {
+  switch (RType) {
+  case RefType::ExternRef:
+    if (!Conf.hasProposal(Proposal::ReferenceTypes)) {
+      return logNeedProposal(ErrCode::Value::MalformedElemType,
+                             Proposal::ReferenceTypes, Off, Node);
+    }
+    [[fallthrough]];
+  case RefType::FuncRef:
+    return RType;
+  default:
+    if (Conf.hasProposal(Proposal::ReferenceTypes)) {
+      return logLoadError(ErrCode::Value::MalformedRefType, Off, Node);
+    } else {
+      return logLoadError(ErrCode::Value::MalformedElemType, Off, Node);
+    }
+  }
+}
+
 } // namespace Loader
 } // namespace WasmEdge
 
